# HydroGuard: A CPLD/FPGA-Based High-Reliability Water Level Monitoring System

<p align="left">
  <img alt="Language" src="https://img.shields.io/badge/Language-VHDL%20(2008)-blue.svg?style=for-the-badge">
  <img alt="Platform" src="https://img.shields.io/badge/Platform-CPLD%20%7C%20FPGA-red.svg?style=for-the-badge">
  <img alt="License" src="https://img.shields.io/badge/License-CC%20BY--SA%204.0-lightgrey.svg?style=for-the-badge">
  <img alt="Target-Device" src="https://img.shields.io/badge/Target%20Device-EPM1270T144C5%20-orange.svg?style=for-the-badge">
</p>

**HydroGuard** 是一个基于 VHDL 的模块化数字系统，实现了一个功能完备、高可靠性的水位监控、多级报警与自动控制平台。

系统以 CPLD/FPGA 为核心控制器，通过超声波传感器进行高精度水位探测，并结合 LCD 屏、数码管、双色点阵和蜂鸣器提供全面的声光报警与状态反馈。系统内置自动泄洪逻辑，并提供完整的手动干预功能，适用于需要高可靠性和实时反馈的水位监控应用。

>  本项目为“北京邮电大学 - 数字电路与逻辑设计实验（下）”课程题目3。

## 🚀 核心功能 (Features)

### 1. 传感与自检 (Sensing & Self-Test)
* **高精度测距：** 驱动 **HC-SR04** 超声波传感器，实时捕获回波时间并将其精确换算为物理距离（mm）。
* **开机自检 (POST)：** 系统启动后，首先对超声波传感器执行功能自检。
    * **成功：** 传感器返回有效信号，系统进入正常监控模式。
    * **失败：** 传感器无响应或超时，系统将锁定在错误界面 (LCD 显示 "ULTRASONIC FAIL")，以防止基于错误数据的误操作。

### 2. 多模态信息显示 (Multi-Modal Display)
* **LCD 128x64 显示屏 (主信息中心)：**
    * **图形化 UI：** 实时显示水位数值 (mm)、系统状态（安全、警惕、危险、泄洪）、泄洪模式（自动/手动）及泄洪速度。
    * **启动画面：** 开机显示项目标题及开发者信息。
    * **高效刷新：** 采用静态标签一次性写入和动态数据增量更新的策略，避免屏幕闪烁。
* **8 位 7 段数码管：**
    * **核心数据：** 实时显示三位数的水位值 (mm) 和一位的状态码 (1-4)。
    * **辅助数据：** 显示当前的泄洪速度档位 (1-3)，非泄洪模式下熄灭。
    * **视觉警报：** “危险”状态下，水位数值以 2Hz 频率闪烁。
* **8x8 双色 LED 点阵：**
    * **水位可视化：** 以柱状图直观显示当前水位。
    * **状态颜色编码：** 安全（绿色）、警惕（黄色）、危险及泄洪（红色）。
    * **泄洪动画：** 泄洪模式下，切换为红色竖条扫描动画，动画速度与泄洪速度档位同步。

### 3. 报警与控制逻辑 (Alarm & Control Logic)
* **多级声光报警：**
    * **蜂鸣器：** 报警声音的间隔随水位增高（警惕 -> 危险 -> 泄洪）而缩短，实现急促程度递增的听觉报警。
    * **视觉协同：** 点阵颜色和数码管闪烁提供同步视觉警示。
* **自动泄洪控制 (闭环)：**
    * 当水位超过阈值 (800mm) 时，系统自动进入 `DRAINING` 模式，并激活 `floodgate_open_o` 信号。
    * 当水位回落至“安全水位”时，系统自动停止泄洪。
* **手动干预系统：**
    * **模式切换 (SW0)：** 在“自动速度”（由水位决定）和“手动速度”之间切换。
    * **强制泄洪 (BTN7)：** 在“危险”状态下可手动启动泄洪。在泄洪期间，可随时手动停止。
    * **速度调节 (BTN2)：** 在“手动速度”模式下，循环切换 1-2-3 档泄洪速度。

## 🛠️ 硬件需求 (Hardware Requirements)

* **核心板：** 任意 Altera (Intel) CPLD/FPGA 开发板 (本项目基于 EPM1270T144C5)
* **传感器：** 1x HC-SR04 超声波测距模块
* **显示器：** 1x LCD12864 液晶显示屏 (ST7920 控制器)
* **数码管：** 1x 8位共阴极 7 段数码管模块
* **点阵：** 1x 8x8 共阳极、行扫描双色 LED 点阵模块
* **音频：** 1x 蜂鸣器（有源或无源驱动）
* **输入：** 2x 瞬时按钮 (低电平有效), 1x 拨码开关

## 📁 软件架构 (Software Architecture)

本项目完全使用 **VHDL (VHDL-2008 标准)** 编写，采用了自顶向下的模块化设计思想。

* `HydroGuard.vhd`: **(顶层实体)** 负责实例化所有子模块，管理顶层系统状态机 (如 `NORMAL_MONITORING` / `DRAINING` 模式切换)，并整合所有并发与时序逻辑。
* `hc_sr04.vhd`: **(超声波驱动)** 负责 `Trig` 脉冲生成、`Echo` 回波捕获，以及高效的距离计算（详见技术细节）。
* `lcd_12864.vhd`: **(LCD 驱动核心)** 图形点阵渲染引擎，负责将 ASCII 码从 UFM 字库中取出并“绘制”到屏幕上。
* `seven_segment_driver.vhd`: **(数码管驱动)** 8 位数码管动态扫描与 BCD 译码驱动。
* `led_matrix_driver.vhd`: **(点阵驱动)** 8x8 双色点阵行扫描与颜色数据解析驱动。
* `buzzer_driver.vhd`: **(蜂鸣器驱动)** PWM 方波生成器，通过分频值控制音调。
* `debounce.vhd`: **(按键消抖)** 通用型按键消抖模块，输出干净的单周期脉冲信号。

## ⚡ 部署指南 (Getting Started)

1.  在 Quartus Prime (或 Quartus II) 中新建一个项目。
2.  将本项目中的所有 `.vhd` 源文件添加至项目中。
3.  打开 **Pin Planner** (引脚规划器)。
4.  根据 `HydroGuard.vhd` 顶层实体的 `port` 列表，将每个端口信号分配到开发板原理图上对应的物理引脚。
5.  点击 **Start Compilation** (开始编译)。
6.  编译成功后，打开 **Programmer** (编程器)。
7.  将生成的 `.sof` (FPGA) 或 `.pof` (CPLD) 编程文件下载到目标设备。

## 🔬 技术亮点：在 CPLD 上实现极限资源优化

本项目最大的挑战是在 **EPM1270T144C5** 这样一颗资源极其有限的 CPLD 上（仅 1270 个逻辑单元 LEs）实现如此复杂的功能。最终资源占用达到了 **93% (1181/1270 LEs)**。

CPLD 没有内置 DSP 硬件乘法器，任何一个 `*` 或 `/` 操作都可能消耗海量的 LEs。本项目采用了一系列逻辑优化技巧，以在“零成本”或“极低成本”下实现复杂的数学运算和图形界面。

### 1. "零成本"测距：用移位-加法替代乘法器

* **需求：** 将超声波回波计数值 `count` 转换为毫米 `D_mm`。根据标定，公式约为 `D_mm ≈ (count * 48) / 1024`。
* **挑战：** `* 48` 操作对于 CPLD 来说过于昂贵。
* **优化：** 利用数学分解 `48 = 32 + 16`。
* **实现：**
    * 原始公式 `(count * 48) >> 10`
    * 优化为 `((count << 5) + (count << 4)) >> 10`
    * 在 VHDL 中，`<< 5` (左移5位) 和 `>> 10` (右移10位) 仅仅是**硬件连线 (wiring)**，不消耗任何逻辑单元。
    * **结果：** 我们用**一个加法器**取代了一个庞大的乘法器，极大节省了资源。

### 2. 高效的二进制转 BCD：“Double Dabble”算法

* **需求：** 将 10-bit 的二进制距离值 `distance_reg` 转换为三个 BCD 码（百、十、个位），用于驱动数码管。
* **挑战：** 传统的“除10取余”法需要除法器，这在 CPLD/FPGA 上是灾难性的。
* **优化：** 采用了 **"Double Dabble"（移位加三）算法**。
* **实现：** 在一个 `for` 循环中，每次对一个24位的寄存器进行左移，并在移位前检查每个4-bit (nibble) BCD 块，如果其值 `> 4`，则对其 `+3`。该算法完全由移位、比较和加法构成，逻辑开销极小。

### 3. "零 LE"字库：利用 UFM 打造自定义图形界面

* **需求：** 在 128x64 屏幕上显示美观的 ASCII 字符（英文、数字、标点）。
* **挑战：** 将一个完整的 8x8 像素字库（例如 95 个字符 * 8x8 像素 = 6080 bits）存储在逻辑单元（LEs）中是**绝对不可能**的，它会占用所有资源。
* **发现：** MAX II 系列 CPLD 内部含有一块 **User Flash Memory (UFM)** 块。这块 UFM 提供了 **8192 bits ** 的非易失性存储空间，并且 **不占用任何逻辑单元（LEs）**！
* **实现：**
    1.  **字体选择：** 采用开源的 [缝合像素字体 / Fusion Pixel Font](https://github.com/TakWolf/fusion-pixel-font) 作为字形库。
    2.  **数据转换：** 将所选字体的 8x8 点阵数据提取出来，转换为 Quartus 支持的内存初始化文件 (`.mif`)。
    3.  **实例化 ROM：** 在 VHDL 中，我们实例化了一个 `font_ufm` (RAM/ROM) 模块，将其内容指向该 `.mif` 文件。
    4.  **重写 LCD 驱动：** `lcd_12864.vhd` 被重写为一个**图形点阵渲染引擎**。当主程序请求显示 ASCII 码为 `65` ('A') 时，驱动程序会以 `65` 为地址，从 UFM 中查找 'A' 的 8x8 点阵数据（共8个字节），然后逐字节（逐行）地将这8个字节的像素数据写入 LCD 的图形 RAM (GDRAM) 中，从而“画”出一个 'A'。


## 🙏 致谢 (Acknowledgements)

* **字体库：** 本项目 UI 使用了 [Fusion Pixel Font](https://github.com/TakWolf/fusion-pixel-font)，感谢 @TakWolf 的出色工作。
* **生成式人工智能：** Google Gemini、Kiro、Cursor 在本项目的设计和文档编写中承担了重要作用，将项目周期压缩至3周完成。

## 📄 许可证 (License)

本项目基于 [知识共享-署名-相同方式共享 4.0 国际 (CC BY-SA 4.0)](https://creativecommons.org/licenses/by-sa/4.0/deed.zh) 许可证授权。
